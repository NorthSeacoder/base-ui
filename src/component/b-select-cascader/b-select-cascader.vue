<!-- @author Kyles Light -->
<!-- @email kuilin@yangqianguan.com -->
<!-- @date 2018-07-03 15:47:19.191 -->
<!-- @desc generated by yqg-cli@0.2.2 -->

<template>

    <div class="b-select-cascader">
        <div
            v-b-click-outside="closeMenu"
            :class="{'disabled': disabled, 'b-resettable': canBeReset}"
            class="b-select">
            <b-input
                ref="input"
                :name="name"
                :value="hint"
                :disabled="disabled"
                :placeholder="placeholder"
                type="text"
                @input="onInput"
                @focus="openMenu"
                @keydown="handleKeyDown">
                <i
                    slot="right"
                    :class="{'b-select-icon-active': menuOpen}"
                    class="b-right-icon b-icon-arrow-bottom"
                    @click="reset"></i>
            </b-input>

            <b-popper :visible="menuOpen">
                <b-select-cascader-menu
                    v-if="showSelectMenu"
                    :list="list"
                    :value="selectedList"
                    :search-text="hint"
                    :enable-emit-list="options.enableEmitList"
                    @choose="choose"/>

                <div v-else>
                    <b-select-menu
                        ref="filterMenu"
                        :map="filterMap"
                        :value="searchText"
                        @choose="chooseFilter"/>
                </div>
            </b-popper>
        </div>
    </div>

</template>

<script type="text/babel">

    import KeyCodeMap from '../../util/keyCodeMap';
    import BSelectMenu from '../b-select/b-select-menu.vue';

    import {
        getSelectedListFromSingleValue,
        getSelectedListFromListValue,
        getValueFilterMap
    } from './helper/helper';
    import BSelectCascaderMenu from './b-select-cascader-menu.vue';

    export default {
        name: 'BSelectCascader',

        components: {BSelectCascaderMenu, BSelectMenu},

        model: {
            prop: 'value',
            event: 'change'
        },

        props: {
            value: {
                type: null,
                required: true
            },
            list: {
                type: Array,
                required: true
            },
            options: {
                type: Object,
                default: () => ({})
            },
            name: {
                type: String,
                default: ''
            },
            placeholder: {
                type: String,
                default: '请选择'
            },
            disabled: {
                type: Boolean,
                default: false
            },
            enableReset: {
                type: Boolean,
                default: true
            }
        },

        data() {
            return {
                menuOpen: false,
                searchText: null,
                selectedList: [],
                originFilterMap: {}
            };
        },

        computed: {
            filterMap() {
                const {originFilterMap, searchText} = this;
                if (!searchText) return originFilterMap;

                const selectedReg = new RegExp(searchText, 'i');
                return Object.entries(originFilterMap)
                      .filter(pair => selectedReg.test(pair[1]))
                      .reduce((acc, [key, value]) => {
                          acc[key] = value;
                          return acc;
                      }, {});
            },

            canBeReset() {
                const {enableReset, selectedText, disabled} = this;
                return !disabled && enableReset && !!selectedText;
            },

            selectedText() {
                const {selectedList} = this;

                return selectedList.map(({label}) => label).join('/');
            },

            hint() {
                const {searchText, selectedText} = this;
                return searchText === null ? selectedText : searchText;
            },

            showSelectMenu() {
                return !this.searchText;
            }
        },

        mounted() {
            const {options: {enableEmitList = false}, value, list} = this;
            const selectedList = enableEmitList
                ? getSelectedListFromListValue(list, value)
                : getSelectedListFromSingleValue(list, value);

            this.selectedList = selectedList;
            this.originFilterMap = getValueFilterMap(list);
        },

        methods: {
            onInput(value) {
                this.searchText = value;
            },

            openMenu() {
                this.menuOpen = true;
            },

            closeMenu() {
                const {$refs: {input}} = this;
                this.menuOpen = false;
                this.searchText = null;

                input.blur();
            },

            reset() {
                const {disabled} = this;
                if (disabled) return;

                this.$emit('change', null);
                this.selectedList = [];
                this.closeMenu();
            },

            choose(selectedList) {
                const vm = this;
                const {options: {
                    enableEmitList = false
                }} = vm;

                const leafItem = selectedList[selectedList.length - 1];
                if (!leafItem.children || !leafItem.children.length) {
                    vm.closeMenu(); // if is leaf item, close menu
                }

                if (enableEmitList) {
                    vm.$emit('change', selectedList.map(({value}) => (value)));
                    vm.selectedList = selectedList;
                    return;
                }

                // when enableEmitList is false, emit change only if is leaf item
                if (!leafItem.children || !leafItem.children.length) {
                    vm.$emit('change', leafItem.value);
                    vm.selectedList = selectedList;
                }
            },

            chooseFilter(value) {
                try {
                    this.choose(JSON.parse(value));
                } catch (err) {
                    // ignore err
                }

                this.searchText = null;
            },

            handleKeyDown(TargetValue, {keyCode}) {
                const vm = this;
                const {$refs: {filterMenu}, showSelectMenu} = vm;

                if (showSelectMenu) return;

                switch (keyCode) {
                    case KeyCodeMap.up:
                    case KeyCodeMap.down: {
                        filterMenu.handleKeyDown(keyCode);
                        break;
                    }
                    case KeyCodeMap.tab:
                    case KeyCodeMap.esc: {
                        vm.closeMenu();
                        break;
                    }
                    case KeyCodeMap.enter: {
                        filterMenu.handleKeyDown(keyCode);
                        vm.closeMenu();
                        break;
                    }
                    default: // ignore
                }
            }
        }
    };

</script>

